CREATE TABLE pam_1_0_0.scoreLayers
(
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(250) NOT NULL,
    settings jsonb,
    normalization FLOAT
)
WITH (
    OIDS = FALSE
);


CREATE TABLE pam_1_0_0.estimatedScoreGrid
(
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "row" INTEGER,
    "column" INTEGER,
    layer INT REFERENCES pam_1_0_0.scoreLayers (id),
    "score" FLOAT,
    "min" FLOAT,
    "max" FLOAT,
    "avg" FLOAT,
	shape geometry
)
WITH (
    OIDS = FALSE
);


CREATE TABLE pam_1_0_0.bands
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    layer integer,
    value double precision,
    range numrange,
    labelConfig jsonb,
    CONSTRAINT bands_pkey PRIMARY KEY (id),
    CONSTRAINT bands_layer_fkey FOREIGN KEY (layer)
        REFERENCES pam_1_0_0.scorelayers (id) MATCH SIMPLE
);


CREATE TABLE pam_1_0_0.shapeScore
(
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    layer INT REFERENCES pam_1_0_0.scoreLayers (id),
    shape INT REFERENCES pam_1_0_0.shapes (id),
    "band" INT REFERENCES pam_1_0_0.bands (id),
    "score" FLOAT,
    "min" FLOAT,
    "max" FLOAT,
    "avg" FLOAT,
    "buffer" FLOAT,
    "state" INT 
)
WITH (
    OIDS = FALSE
);

CREATE TABLE pam_1_0_0.shapeScoreEstimatedParts
(
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    shape INT REFERENCES pam_1_0_0.shapes (id),
    fullyWithin BOOLEAN,
    gridID INT REFERENCES pam_1_0_0.estimatedScoreGrid
    
)
WITH (
    OIDS = FALSE
);




CREATE OR REPLACE FUNCTION pam.generateEstimatesForShape ( in_id integer )
RETURNS VOID AS $$	
DECLARE
    target geometry;
BEGIN

    /*
        Set the state to estimating
    */
    UPDATE pam_1_0_0.shapeScore
    SET state = 1
    WHERE shape = in_id;



    /*
        Grab the target
    */
    SELECT shape into target
    FROM pam_1_0_0.shapes
    WHERE id = in_id;


    /*
        Create two tem tables housing the fully within squares and the partially within squares
        TODO: Replace the estimatedscoregrid table with a function taking a shape and area?
    */
    CREATE TEMP TABLE fullyWithin AS
    SELECT id
    FROM pam_1_0_0.estimatedscoregrid
    where ST_Within(shape,target);

    CREATE TEMP TABLE partiallyWithin AS
    SELECT id
    FROM pam_1_0_0.estimatedscoregrid 
    where ST_Intersects(shape, target);



    /*
        Organize some infos
    */
    create TEMP TABLE targetScoreIDs AS
    select false as "full",partiallyWithin.id from partiallyWithin
    except select false,id from fullyWithin
    union
    select true as "full",id from fullyWithin;



    /* Only for debugging

    DELETE FROM pam_1_0_0.shapeScoreEstimatedParts
    WHERE shape = in_id;

    INSERT INTO pam_1_0_0.shapeScoreEstimatedParts
    ( shape
    , fullyWithin
    , gridId
    )
    SELECT 
        in_id,
        "full",
        "id"
    FROM targetScoreIDs;

    */



    /*
        Insert our scores
        TODO: Get the layerid from above as were assuming 1 layer atm
        TODO: Replace the estimatedscoregrid table with a function taking a shape and area?
    */

    UPDATE pam_1_0_0.shapeScore
    set
        "score" = grid.score,
        "min" = grid.min,
        "max" = grid.max,
        "avg" = grid.avg,
        "state" = grid.state
    FROM
    (
        SELECT 
            layer as gridLayer, 
            SUM(score) as "score", 
            MIN(min) as "min", 
            MAX(max) as "max", 
            AVG(avg) as "avg", 
            2 as "state" --Estimated
        FROM pam_1_0_0.estimatedscoregrid as grid
        JOIN targetScoreIDs as scores
        ON grid.id = scores.id
        GROUP BY grid.layer
    ) as grid
    WHERE shape = in_id
    AND layer = grid.gridLayer;


    UPDATE pam_1_0_0.shapeScore
    SET state = 2, avg = 0
    WHERE shape = in_id AND state = 1;

    /*
        Cleanup what we created
    */
    DROP TABLE fullyWithin;
    DROP TABLE partiallyWithin;
    DROP TABLE targetScoreIDs;
		
END $$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION pam.getScoresByOID ( in_id integer )
RETURNS TABLE ( id integer, score float, buffer float, avg float, min float, max float, layer int, band int, labelConfig jsonb ) AS $$
DECLARE
	normalized float;
BEGIN
	SELECT score.avg / layer.normalization into normalized
	FROM pam_1_0_0.shapescore as score
	JOIN pam_1_0_0.scorelayers as layer
	ON score.layer = layer.id
	JOIN pam_1_0_0.shapes as shape
	ON score.shape = shape.id
	WHERE shape.objectid = in_id;
	
	RETURN QUERY
	--SELECT 0,normalized,1,0.0::float;
	
	SELECT 
		score.id,
		case when score.avg <> 0 then band.value + (( normalized )::numeric - lower(band.range)) / (upper(band.range) - lower(band.range))
		ELSE 0 END  as score,
		0.0::float,
		score.avg,
		score.min,
		score.max,
		score.layer,
		band.id,
		band.labelConfig
		--score.shape,
		--score.min,
		--score.max,
		--score.avg,
		
	FROM pam_1_0_0.shapescore as score
	LEFT JOIN pam_1_0_0.bands as band
	ON ( normalized )::numeric <@ band.range
	JOIN pam_1_0_0.shapes as shape
	ON score.shape = shape.id
	WHERE shape.objectid = in_id
	AND state > 1;

END $$  LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION pam.deleteScoresForObject ( in_objectId integer, in_fieldId integer )
RETURNS VOID AS $$
BEGIN
    DELETE 
    FROM pam_1_0_0.shapeScore 
    WHERE shape in 
        ( 
            SELECT id 
            FROM pam_1_0_0.shapes 
            WHERE objectid = in_objectId
                AND fieldid = in_fieldId
        ); 

    DELETE 
    FROM pam_1_0_0.shapeScoreEstimatedParts 
    WHERE shape in 
        (
            SELECT id 
            FROM pam_1_0_0.shapes 
            WHERE objectid = in_objectId 
            AND fieldid = in_fieldId
        );
END $$ LANGUAGE plpgsql;